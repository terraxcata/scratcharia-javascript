<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scratcharia Map Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #map-container {
            display: grid;
            grid-template-columns: repeat(350, 2px); 
            grid-template-rows: repeat(160, 2px);
            width: 700px;
            height: 320px; 
            overflow: auto;
            border: 1px solid #475569;
            
            /* Zoom properties */
            transform-origin: top left;
            transition: transform 0.2s ease-in-out;
        }
        .tile {
            width: 2px;
            height: 2px;
            box-sizing: border-box;
            cursor: pointer;
            transition: background-color 0.1s;
        }
        #map-container::-webkit-scrollbar { width: 8px; height: 8px; }
        #map-container::-webkit-scrollbar-thumb { background: #3b82f6; border-radius: 4px; }
        #map-container::-webkit-scrollbar-track { background: #1e293b; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        };
    </script>
</head>
<body class="bg-gray-900 text-gray-100 p-4 font-sans min-h-screen flex flex-col items-center">

    <div class="max-w-5xl w-full">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">350x160 Tile Map Editor (Data Loaded)</h1>
        
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg mb-6 flex flex-wrap justify-between items-center space-y-4 md:space-y-0">
            
            <div class="flex flex-col space-y-2 w-full md:w-1/3">
                <h2 class="text-xl font-semibold text-blue-300">Block Selector</h2>
                <select id="blockSelectorDropdown" class="p-3 border border-gray-600 rounded-lg bg-gray-700 text-sm focus:ring-blue-500 focus:border-blue-500 text-white cursor-pointer"></select>
                <div id="current-block-preview" class="flex items-center mt-2 text-sm font-medium">
                    Current: <span id="current-block-icon" class="mx-2 text-xl inline-block w-6 h-6 text-center leading-6">‚óªÔ∏è</span>
                    <span id="current-block-label">Loading...</span>
                </div>
            </div>
            
            <div class="flex items-center space-x-2 md:w-1/4 justify-center">
                <span class="text-lg font-medium">Zoom:</span>
                <button id="zoomOutButton" class="bg-gray-700 hover:bg-gray-600 text-white font-bold w-10 h-10 rounded-full text-xl shadow-md transition duration-200">-</button>
                <span id="zoomLevelDisplay" class="text-xl font-bold text-blue-300 w-12 text-center">1.0x</span>
                <button id="zoomInButton" class="bg-gray-700 hover:bg-gray-600 text-white font-bold w-10 h-10 rounded-full text-xl shadow-md transition duration-200">+</button>
            </div>
            
            <div class="flex flex-col space-y-2 w-full md:w-1/3">
                <input type="file" id="fileInput" accept=".txt,.csv" class="p-2 border border-gray-600 rounded-lg bg-gray-700 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600">
                <button id="exportButton" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                    Export Map Data
                </button>
            </div>
        </div>
        
        <div class="flex flex-col items-center">
            <div id="status-message" class="text-red-400 mb-2 h-6"></div>
            <div id="map-wrapper" class="p-2 bg-gray-700 rounded-xl shadow-inner">
                <div id="map-container" class="transform origin-top-left">
                </div>
            </div>
            <p class="mt-4 text-sm text-gray-400">Map dimensions: 350 (W) x 160 (H) = 56,000 tiles.</p>
            <p class="text-xs text-gray-500 mt-1">Data maps from the bottom-right tile (349, 159) backwards to the top-left.</p>
        </div>

    </div>

    <!-- 
    <script id="block-data-json" type="application/json">
        {
            "0": { "label": "Empty", "color": "bg-gray-900", "tile": "#111827", "symbol": "‚óªÔ∏è" },
            "1": { "label": "Wall (Stone)", "color": "bg-gray-400", "tile": "#9ca3af", "symbol": "üß±" },
            "2": { "label": "Start Point", "color": "bg-green-600", "tile": "#16a34a", "symbol": "üü¢" },
            "3": { "label": "Exit Gate", "color": "bg-red-600", "tile": "#dc2626", "symbol": "üö©" },
            "4": { "label": "Water (Deep)", "color": "bg-blue-500", "tile": "#3b82f6", "symbol": "üåä" },
            "5": { "label": "Sand Pit", "color": "bg-yellow-500", "tile": "#f59e0b", "symbol": "‚è≥" },
            "6": { "label": "Wooden Bridge", "color": "bg-yellow-800", "tile": "#b45309", "symbol": "üåâ" },
            "7": { "label": "Lava Flow", "color": "bg-red-800", "tile": "#991b1b", "symbol": "üåã" },
            "8": { "label": "Ice Floor", "color": "bg-cyan-200", "tile": "#a5f3fc", "symbol": "üßä" },
            "9": { "label": "Mossy Brick", "color": "bg-green-700", "tile": "#047857", "symbol": "üåø" }
        }
    </script>
    -->
    
    <script>
        // --- CONFIGURATION ---
        const MAP_WIDTH = 350;
        const MAP_HEIGHT = 160;
        const TOTAL_TILES = MAP_WIDTH * MAP_HEIGHT;
        const ZOOM_STEP = 0.5;
        const MIN_ZOOM = 1.0;
        const MAX_ZOOM = 4.0;
        
        const EXTERNAL_BLOCK_DATA_URL = "https://your-api.com/v1/map_blocks.json";
        
        let mapData = new Array(TOTAL_TILES).fill(0); 
        let currentBlockType = 0;
        let currentZoomLevel = MIN_ZOOM;
        let BLOCK_TYPES = {};
        let MAX_BLOCK_TYPE = 0;

        // --- DOM REFERENCES ---
        const mapContainer = document.getElementById('map-container');
        const fileInput = document.getElementById('fileInput');
        const exportButton = document.getElementById('exportButton');
        const statusMessage = document.getElementById('status-message');
        const blockSelectorDropdown = document.getElementById('blockSelectorDropdown');
        const currentBlockLabel = document.getElementById('current-block-label');
        const currentBlockIcon = document.getElementById('current-block-icon');
        const zoomInButton = document.getElementById('zoomInButton');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');
        const blockDataScript = document.getElementById('block-data-json');


        // --- DATABASE INTERACTION (Simulated Fetch) ---

        /**
         * Simulates fetching block definitions from an external API.
         * In a real app, you would replace the logic inside the try block with:
         * * const response = await fetch(EXTERNAL_BLOCK_DATA_URL);
         * if (!response.ok) throw new Error('Network response failed');
         * return await response.json();
         */
        async function loadBlockData() {
            try {
                statusMessage.textContent = `Fetching block definitions from ${EXTERNAL_BLOCK_DATA_URL}...`;
                
                // --- SIMULATION OF FETCH START ---
                await new Promise(resolve => setTimeout(resolve, 500));
                
                if (!blockDataScript || !blockDataScript.textContent) {
                    throw new Error("Embedded block data not found.");
                }
                
                const data = JSON.parse(blockDataScript.textContent);

                BLOCK_TYPES = data;
                MAX_BLOCK_TYPE = Math.max(...Object.keys(BLOCK_TYPES).map(Number));
                
                statusMessage.textContent = `Successfully loaded ${Object.keys(BLOCK_TYPES).length} block definitions.`;
                setTimeout(() => statusMessage.textContent = '', 3000);
                
                return BLOCK_TYPES;

            } catch (error) {
                const errorMessage = `Error loading block data: ${error.message}. Using default minimum set.`;
                statusMessage.textContent = errorMessage;
                console.error(errorMessage, error);
                
                BLOCK_TYPES = {
                    0: { label: 'Empty', tile: '#111827', symbol: '‚óªÔ∏è' },
                    1: { label: 'Error Block', tile: '#881337', symbol: '‚ùå' }
                };
                MAX_BLOCK_TYPE = 1;
                return BLOCK_TYPES;
            }
        }

        // --- CORE FUNCTIONS ---

        function renderMap(data) {
            mapContainer.innerHTML = ''; 

            const grid = Array.from({ length: MAP_HEIGHT }, () => new Array(MAP_WIDTH).fill(0));
            let dataIndex = 0;
            for (let y = MAP_HEIGHT - 1; y >= 0; y--) {
                for (let x = MAP_WIDTH - 1; x >= 0; x--) {
                    const tileValue = (dataIndex < data.length) ? (data[dataIndex] || 0) : 0;
                    grid[y][x] = tileValue;
                    dataIndex++;
                }
            }

            const finalMapData = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    finalMapData.push(grid[y][x]);
                }
            }
            mapData = finalMapData;

            // Rendering of the tiles
            finalMapData.forEach((value, index) => {
                const blockId = value <= MAX_BLOCK_TYPE ? value : 0;
                const type = BLOCK_TYPES[blockId] || BLOCK_TYPES[0];

                const tile = document.createElement('div');
                tile.className = `tile`;
                // If using Base64: tile.style.backgroundImage = `url(${type.symbol})`;
                tile.style.backgroundColor = type.tile; 
                
                tile.dataset.index = index;
                tile.dataset.value = blockId;
                
                tile.addEventListener('click', handleTileClick);
                
                mapContainer.appendChild(tile);
            });
        }

        function initBlockSelector() {
            blockSelectorDropdown.innerHTML = '';
            
            Object.keys(BLOCK_TYPES).map(Number).sort((a, b) => a - b).forEach(key => {
                const type = BLOCK_TYPES[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${key} - ${type.label}`;
                
                blockSelectorDropdown.appendChild(option);
            });

            blockSelectorDropdown.addEventListener('change', (e) => {
                setCurrentBlockType(e.target.value);
            });

            setCurrentBlockType(0);
        }

        function setCurrentBlockType(type) {
            currentBlockType = Number(type);
            const block = BLOCK_TYPES[currentBlockType] || BLOCK_TYPES[0];
            
            currentBlockLabel.textContent = `${currentBlockType} - ${block.label}`;
            currentBlockIcon.innerHTML = block.symbol;
            
            blockSelectorDropdown.value = currentBlockType;
        }

        function handleTileClick(event) {
            const tile = event.target;
            if (!tile.classList.contains('tile')) return; 

            const index = Number(tile.dataset.index);
            const newBlockValue = currentBlockType;
            
            const type = BLOCK_TYPES[newBlockValue] || BLOCK_TYPES[0];
            tile.style.backgroundColor = type.tile;
            tile.dataset.value = newBlockValue;
            
            mapData[index] = newBlockValue;
        }


        // --- ZOOM FUNCTIONS ---
        function updateZoom() {
            mapContainer.style.transform = `scale(${currentZoomLevel})`;
            zoomLevelDisplay.textContent = `${currentZoomLevel.toFixed(1)}x`;

            const scaledWidth = 700 * currentZoomLevel;
            const scaledHeight = 320 * currentZoomLevel;

            document.getElementById('map-wrapper').style.width = currentZoomLevel > MIN_ZOOM ? `${scaledWidth}px` : '704px'; // 700px + 4px padding
            document.getElementById('map-wrapper').style.height = currentZoomLevel > MIN_ZOOM ? `${scaledHeight}px` : '324px'; // 320px + 4px padding

            zoomOutButton.disabled = currentZoomLevel <= MIN_ZOOM;
            zoomInButton.disabled = currentZoomLevel >= MAX_ZOOM;
            zoomOutButton.classList.toggle('opacity-50', zoomOutButton.disabled);
            zoomInButton.classList.toggle('opacity-50', zoomInButton.disabled);
        }

        function zoomIn() {
            if (currentZoomLevel < MAX_ZOOM) {
                currentZoomLevel = Math.min(MAX_BLOCK_TYPE, currentZoomLevel + ZOOM_STEP);
                updateZoom();
            }
        }

        function zoomOut() {
            if (currentZoomLevel > MIN_ZOOM) {
                currentZoomLevel = Math.max(MIN_ZOOM, currentZoomLevel - ZOOM_STEP);
                updateZoom();
            }
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    const rawValues = content.split(/[,\s]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0)
                        .map(Number);
                    
                    const validData = rawValues.map(v => {
                        const clamped = Math.min(Math.max(0, v), MAX_BLOCK_TYPE);
                        return isNaN(v) ? 0 : clamped;
                    });

                    if (validData.length === 0) {
                        statusMessage.textContent = 'Error: Loaded file contains no valid numerical data.';
                        setTimeout(() => statusMessage.textContent = '', 3000);
                        return;
                    }

                    statusMessage.textContent = `Loaded ${validData.length} values. Mapping to 350x160 grid (BR to TL).`;
                    setTimeout(() => statusMessage.textContent = '', 4000);
                    
                    renderMap(validData);

                } catch (error) {
                    statusMessage.textContent = 'Error processing file data.';
                    console.error('File processing error:', error);
                }
            };
            reader.readAsText(file);
        }

        function handleExport() {
            const grid = [];
            for (let i = 0; i < TOTAL_TILES; i++) {
                const y = Math.floor(i / MAP_WIDTH);
                const x = i % MAP_WIDTH;
                grid.push({ x, y, value: mapData[i] });
            }

            grid.sort((a, b) => {
                if (a.y !== b.y) { return b.y - a.y; }
                return b.x - a.x;
            });

            const outputData = grid.map(item => item.value);
            const csvContent = outputData.join(',');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'map_data.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            statusMessage.textContent = 'Map data exported successfully!';
            setTimeout(() => statusMessage.textContent = '', 3000);
        }
        
        window.onload = async () => {
            await loadBlockData();

            fileInput.addEventListener('change', handleFileLoad);
            exportButton.addEventListener('click', handleExport);
            zoomInButton.addEventListener('click', zoomIn);
            zoomOutButton.addEventListener('click', zoomOut);

            initBlockSelector();
            renderMap(mapData);
            updateZoom(); 
        };

    </script>
</body>
</html>
