<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scratcharia Map Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #map-container {
            display: grid;
            overflow: auto;
            border: 1px solid #475569;
            transform-origin: top left;
            transition: transform 0.2s ease-in-out;
        }
        .tile {
            width: 2px;
            height: 2px;
            box-sizing: border-box;
            cursor: crosshair;
            transition: background-color 0.1s;
        }
        #map-container::-webkit-scrollbar { width: 8px; height: 8px; }
        #map-container::-webkit-scrollbar-thumb { background: #3b82f6; border-radius: 4px; }
        #map-container::-webkit-scrollbar-track { background: #1e293b; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        };
    </script>
</head>
<body class="bg-gray-900 text-gray-100 p-4 font-sans min-h-screen flex flex-col items-center">

    <div class="max-w-5xl w-full">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">Scratcharia Map Editor</h1>
        
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg mb-6 flex flex-wrap justify-between items-start space-y-4 md:space-y-0 md:space-x-4">
            
            <div class="flex flex-col space-y-2 w-full md:w-1/4">
                <h2 class="text-xl font-semibold text-blue-300">Block Selector</h2>
                <select id="blockSelectorDropdown" class="p-3 border border-gray-600 rounded-lg bg-gray-700 text-sm focus:ring-blue-500 focus:border-blue-500 text-white cursor-pointer"></select>
                <div id="current-block-preview" class="flex items-center mt-2 text-sm font-medium">
                    Current: <span id="current-block-icon" class="mx-2 text-xl inline-block w-6 h-6 text-center leading-6">◻️</span>
                    <span id="current-block-label">Loading...</span>
                </div>
            </div>
            
            <div class="flex flex-col space-y-2 w-full md:w-1/4">
                <h2 class="text-xl font-semibold text-blue-300">Map Size (Tiles)</h2>
                <p class="text-xs text-gray-400">Default: 350 (W) x 160 (H)</p>
                <div class="flex space-x-2">
                    <input type="number" id="mapWidthInput" value="350" min="1" max="1000" class="p-2 border border-gray-600 rounded-lg bg-gray-700 text-sm w-1/2" placeholder="Width">
                    <input type="number" id="mapHeightInput" value="160" min="1" max="1000" class="p-2 border border-gray-600 rounded-lg bg-gray-700 text-sm w-1/2" placeholder="Height">
                </div>
                <button id="updateSizeButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1 px-4 rounded-lg shadow-md transition duration-200">
                    Update Map Size
                </button>
                <div class="flex items-center space-x-2 justify-center pt-2">
                    <span class="text-lg font-medium">Zoom:</span>
                    <button id="zoomOutButton" class="bg-gray-700 hover:bg-gray-600 text-white font-bold w-8 h-8 rounded-full text-xl shadow-md transition duration-200">-</button>
                    <span id="zoomLevelDisplay" class="text-lg font-bold text-blue-300 w-10 text-center">1.0x</span>
                    <button id="zoomInButton" class="bg-gray-700 hover:bg-gray-600 text-white font-bold w-8 h-8 rounded-full text-xl shadow-md transition duration-200">+</button>
                </div>
            </div>

            <div class="flex flex-col space-y-2 w-full md:w-1/4">
                <input type="file" id="fileInput" accept=".txt,.csv" class="p-2 border border-gray-600 rounded-lg bg-gray-700 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600">
                <button id="exportButton" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                    Export Map Data
                </button>
            </div>
        </div>
        
        <div class="flex flex-col items-center">
            <div id="status-message" class="text-red-400 mb-2 h-6"></div>
            <div id="map-wrapper" class="p-2 bg-gray-700 rounded-xl shadow-inner">
                <div id="map-container" class="transform origin-top-left">
                </div>
            </div>
            <p id="dimensionsDisplay" class="mt-4 text-sm text-gray-400">Map dimensions: 350 (W) x 160 (H) = 56,000 tiles.</p>
            <p class="text-xs text-gray-500 mt-1">Data maps from the bottom-right tile backwards to the top-left.</p>
        </div>

    </div>
    
    <script>
        let MAP_WIDTH = 350;
        let MAP_HEIGHT = 160;
        let TOTAL_TILES = 0;
        const ZOOM_STEP = 0.5;
        const MIN_ZOOM = 1.0;
        const MAX_ZOOM = 4.0;
        
        const EXTERNAL_BLOCK_DATA_URL = "https://raw.githack.com/terraxcata/scratcharia-javascript/refs/heads/main/map-editor/extracted_costumes.json";
        
        let mapData = []; 
        let currentBlockType = 0;
        let currentZoomLevel = MIN_ZOOM;
        let BLOCK_TYPES = {};
        let MAX_BLOCK_TYPE = 0;
        let isPainting = false;

        const mapContainer = document.getElementById('map-container');
        const fileInput = document.getElementById('fileInput');
        const exportButton = document.getElementById('exportButton');
        const statusMessage = document.getElementById('status-message');
        const blockSelectorDropdown = document.getElementById('blockSelectorDropdown');
        const currentBlockLabel = document.getElementById('current-block-label');
        const currentBlockIcon = document.getElementById('current-block-icon');
        const zoomInButton = document.getElementById('zoomInButton');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');
        const mapWidthInput = document.getElementById('mapWidthInput');
        const mapHeightInput = document.getElementById('mapHeightInput');
        const dimensionsDisplay = document.getElementById('dimensionsDisplay');
        const updateSizeButton = document.getElementById('updateSizeButton');

        const EMPTY_BLOCK_FALLBACK = {
            id: 0,
            costume_name: "air", 
            label: "Air",
            mime_type: null,
            base64_image_data: null 
        };

        function createTileStyles() {
            const styleSheet = document.createElement('style');
            styleSheet.id = 'tile-styles';
            let css = '';

            Object.keys(BLOCK_TYPES).map(Number).sort((a, b) => a - b).forEach(key => {
                const block = BLOCK_TYPES[key];
                const className = `block-${key}`;
                
                let blockCss = '';
                
                if (key === 0) {
                    blockCss = 'background-image: none !important; background-color: transparent !important;';
                } else if (block.base64_image_data) {
                    const base64Mime = block.mime_type || 'image/png';
                    blockCss = `
                        background-image: url(data:${base64Mime};base64,${block.base64_image_data});
                        background-size: 2px 2px;
                        background-color: transparent !important;
                    `;
                } else {
                    blockCss = 'background-image: none; background-color: #f87171 !important;';
                }

                css += `.tile.${className} { ${blockCss} }`;
            });

            styleSheet.textContent = css;
            if (!document.getElementById('tile-styles')) {
                document.head.appendChild(styleSheet);
            }
        }

        async function loadBlockData() {
            try {
                statusMessage.textContent = `Fetching block definitions...`;
                
                const response = await fetch(EXTERNAL_BLOCK_DATA_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const dataArray = await response.json();
                
                BLOCK_TYPES = {};
                BLOCK_TYPES[0] = EMPTY_BLOCK_FALLBACK;
                
                dataArray.forEach((block, index) => {
                    const id = index + 1; 
                    BLOCK_TYPES[id] = { 
                        id: id,
                        label: block.costume_name, 
                        ...block 
                    };
                });
                
                MAX_BLOCK_TYPE = dataArray.length;
                
                statusMessage.textContent = `Successfully loaded ${Object.keys(BLOCK_TYPES).length} block definitions.`;
                setTimeout(() => statusMessage.textContent = '', 3000);
                
                return BLOCK_TYPES;

            } catch (error) {
                const errorMessage = `Error loading block data: ${error.message}. Using default minimum set.`;
                statusMessage.textContent = errorMessage;
                console.error(errorMessage, error);
                
                BLOCK_TYPES = {
                    0: EMPTY_BLOCK_FALLBACK,
                    1: { id: 1, label: 'Error Block', costume_name: 'error', mime_type: 'image/png', base64_image_data: "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAKklEQVR42u3BAQEAAAABIP6fOpgAEAAAAAAAAAAAAAAAAAAAAAF+jYABg2fN+hAAAAABJRU5ErkJggg==" }
                };
                MAX_BLOCK_TYPE = 1;
                return BLOCK_TYPES;
            }
        }

        function paintTile(tileElement) {
            if (!tileElement || !tileElement.classList.contains('tile')) return;

            const index = Number(tileElement.dataset.index);
            const oldBlockValue = Number(tileElement.dataset.value);
            const newBlockValue = currentBlockType;
            
            if (oldBlockValue === newBlockValue) return; 

            if (oldBlockValue !== undefined) {
                tileElement.classList.remove(`block-${oldBlockValue}`);
            }
            
            tileElement.classList.add(`block-${newBlockValue}`);
            
            tileElement.dataset.value = newBlockValue;
            mapData[index] = newBlockValue;
        }

        function handleTileMouseOver(event) {
            if (isPainting && event.target.classList.contains('tile')) {
                paintTile(event.target);
            }
        }

        function startPainting(event) {
            if (event.buttons === 1 && event.target.classList.contains('tile')) { 
                isPainting = true;
                paintTile(event.target);
            }
        }

        function stopPainting() {
            isPainting = false;
        }

        function renderMap(data) {
            mapContainer.innerHTML = ''; 
            const fragment = document.createDocumentFragment(); 

            const grid = Array.from({ length: MAP_HEIGHT }, () => new Array(MAP_WIDTH).fill(0));
            let dataIndex = 0;
            
            if (data.length === TOTAL_TILES) {
                for (let y = MAP_HEIGHT - 1; y >= 0; y--) {
                    for (let x = MAP_WIDTH - 1; x >= 0; x--) {
                        const tileValue = (dataIndex < data.length) ? (data[dataIndex] || 0) : 0;
                        grid[y][x] = tileValue;
                        dataIndex++;
                    }
                }
            } else {
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        grid[y][x] = 0;
                    }
                }
            }


            const finalMapData = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    finalMapData.push(grid[y][x]);
                }
            }
            mapData = finalMapData;

            finalMapData.forEach((value, index) => {
                const blockId = value <= MAX_BLOCK_TYPE ? value : 0;
                
                const tile = document.createElement('div');
                tile.className = `tile block-${blockId}`; 
                
                tile.dataset.index = index;
                tile.dataset.value = blockId;
                
                tile.addEventListener('mouseover', handleTileMouseOver);
                
                fragment.appendChild(tile); 
            });

            mapContainer.appendChild(fragment); 
        }

        function initBlockSelector() {
            blockSelectorDropdown.innerHTML = '';
            
            Object.keys(BLOCK_TYPES).map(Number).sort((a, b) => a - b).forEach(key => {
                const type = BLOCK_TYPES[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${key} - ${type.costume_name}`;
                
                blockSelectorDropdown.appendChild(option);
            });

            blockSelectorDropdown.addEventListener('change', (e) => {
                setCurrentBlockType(e.target.value);
            });

            setCurrentBlockType(0);
        }

        function setCurrentBlockType(type) {
            currentBlockType = Number(type);
            const block = BLOCK_TYPES[currentBlockType] || BLOCK_TYPES[0];
            
            currentBlockLabel.textContent = `${currentBlockType} - ${block.costume_name}`;
            
            const base64Mime = block.mime_type || 'image/png';
            const base64Data = block.base64_image_data;
            if (base64Data) {
                currentBlockIcon.innerHTML = '';
                currentBlockIcon.style.backgroundImage = `url(data:${base64Mime};base64,${base64Data})`;
                currentBlockIcon.style.backgroundSize = '100% 100%';
                currentBlockIcon.style.backgroundColor = 'transparent';
            } else {
                currentBlockIcon.innerHTML = '';
                currentBlockIcon.style.backgroundImage = 'none';
                currentBlockIcon.style.backgroundColor = 'transparent';
            }
            
            blockSelectorDropdown.value = currentBlockType;
        }

        function updateZoom() {
            mapContainer.style.transform = `scale(${currentZoomLevel})`;
            zoomLevelDisplay.textContent = `${currentZoomLevel.toFixed(1)}x`;

            const baseWidthPx = MAP_WIDTH * 2;
            const baseHeightPx = MAP_HEIGHT * 2;

            const scaledWidth = baseWidthPx * currentZoomLevel;
            const scaledHeight = baseHeightPx * currentZoomLevel;
            
            document.getElementById('map-wrapper').style.width = currentZoomLevel > MIN_ZOOM ? `${scaledWidth + 4}px` : `${baseWidthPx + 4}px`;
            document.getElementById('map-wrapper').style.height = currentZoomLevel > MIN_ZOOM ? `${scaledHeight + 4}px` : `${baseHeightPx + 4}px`;

            zoomOutButton.disabled = currentZoomLevel <= MIN_ZOOM;
            zoomInButton.disabled = currentZoomLevel >= MAX_ZOOM;
            zoomOutButton.classList.toggle('opacity-50', zoomOutButton.disabled);
            zoomInButton.classList.toggle('opacity-50', zoomInButton.disabled);
        }

        function zoomIn() {
            if (currentZoomLevel < MAX_ZOOM) {
                currentZoomLevel = Math.min(MAX_ZOOM, currentZoomLevel + ZOOM_STEP); 
                updateZoom();
            }
        }

        function zoomOut() {
            if (currentZoomLevel > MIN_ZOOM) {
                currentZoomLevel = Math.max(MIN_ZOOM, currentZoomLevel - ZOOM_STEP);
                updateZoom();
            }
        }

        function initializeMap() {
            MAP_WIDTH = parseInt(mapWidthInput.value) || 350;
            MAP_HEIGHT = parseInt(mapHeightInput.value) || 160;

            MAP_WIDTH = Math.max(1, Math.min(1000, MAP_WIDTH));
            MAP_HEIGHT = Math.max(1, Math.min(1000, MAP_HEIGHT));
            
            mapWidthInput.value = MAP_WIDTH;
            mapHeightInput.value = MAP_HEIGHT;

            TOTAL_TILES = MAP_WIDTH * MAP_HEIGHT;

            mapContainer.style.gridTemplateColumns = `repeat(${MAP_WIDTH}, 2px)`;
            mapContainer.style.gridTemplateRows = `repeat(${MAP_HEIGHT}, 2px)`;
            mapContainer.style.width = `${MAP_WIDTH * 2}px`;
            mapContainer.style.height = `${MAP_HEIGHT * 2}px`;

            mapData = new Array(TOTAL_TILES).fill(0);
            
            dimensionsDisplay.textContent = `Map dimensions: ${MAP_WIDTH} (W) x ${MAP_HEIGHT} (H) = ${TOTAL_TILES.toLocaleString()} tiles.`;
            
            renderMap(mapData);
            updateZoom();
        }

        function updateDimensions() {
            const oldWidth = MAP_WIDTH;
            const oldHeight = MAP_HEIGHT;
            
            const newWidth = Math.max(1, Math.min(1000, parseInt(mapWidthInput.value) || 350));
            const newHeight = Math.max(1, Math.min(1000, parseInt(mapHeightInput.value) || 160));
            
            if (newWidth === oldWidth && newHeight === oldHeight) return;

            const oldMapData = [...mapData];
            
            MAP_WIDTH = newWidth;
            MAP_HEIGHT = newHeight;
            TOTAL_TILES = MAP_WIDTH * MAP_HEIGHT;

            mapWidthInput.value = MAP_WIDTH;
            mapHeightInput.value = MAP_HEIGHT;

            const newMapData = new Array(TOTAL_TILES).fill(0);

            const widthLimit = Math.min(oldWidth, newWidth);
            const heightLimit = Math.min(oldHeight, newHeight);

            for (let y = 0; y < heightLimit; y++) {
                for (let x = 0; x < widthLimit; x++) {
                    const oldIndex = y * oldWidth + x;
                    const newIndex = y * newWidth + x;
                    
                    if (oldIndex < oldMapData.length && newIndex < newMapData.length) {
                         newMapData[newIndex] = oldMapData[oldIndex];
                    }
                }
            }
            
            mapContainer.style.gridTemplateColumns = `repeat(${MAP_WIDTH}, 2px)`;
            mapContainer.style.gridTemplateRows = `repeat(${MAP_HEIGHT}, 2px)`;
            mapContainer.style.width = `${MAP_WIDTH * 2}px`;
            mapContainer.style.height = `${MAP_HEIGHT * 2}px`;

            dimensionsDisplay.textContent = `Map dimensions: ${MAP_WIDTH} (W) x ${MAP_HEIGHT} (H) = ${TOTAL_TILES.toLocaleString()} tiles.`;
            
            renderMap(newMapData);
            updateZoom();

            statusMessage.textContent = 'Map Updated.';
            setTimeout(() => statusMessage.textContent = '', 4000);
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    const rawValues = content.split(/[,\s]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0)
                        .map(Number);
                    
                    if (rawValues.length !== TOTAL_TILES) {
                        statusMessage.textContent = `Warning: Loaded ${rawValues.length} values, expected ${TOTAL_TILES}. Map data will be partially loaded or truncated.`;
                    }
                    
                    const validData = rawValues.map(v => {
                        const clamped = Math.min(Math.max(0, v), MAX_BLOCK_TYPE);
                        return isNaN(v) ? 0 : clamped;
                    });

                    if (validData.length === 0) {
                        statusMessage.textContent = 'Error: Loaded file contains no valid numerical data.';
                        setTimeout(() => statusMessage.textContent = '', 3000);
                        return;
                    }

                    renderMap(validData);
                    statusMessage.textContent = `Map data loaded successfully!`;
                    setTimeout(() => statusMessage.textContent = '', 4000);
                    

                } catch (error) {
                    statusMessage.textContent = 'Error processing file data.';
                    console.error('File processing error:', error);
                }
            };
            reader.readAsText(file);
        }

        function handleExport() {
            const grid = [];
            for (let i = 0; i < TOTAL_TILES; i++) {
                const y = Math.floor(i / MAP_WIDTH);
                const x = i % MAP_WIDTH;
                grid.push({ x, y, value: mapData[i] });
            }

            grid.sort((a, b) => {
                if (a.y !== b.y) { return b.y - a.y; }
                return b.x - a.x;
            });

            const outputData = grid.map(item => item.value);
            const csvContent = outputData.join(',');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `map_data_${MAP_WIDTH}x${MAP_HEIGHT}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            statusMessage.textContent = 'Map data exported successfully!';
            setTimeout(() => statusMessage.textContent = '', 3000);
        }
        
        window.onload = async () => {
            updateSizeButton.addEventListener('click', updateDimensions);

            fileInput.addEventListener('change', handleFileLoad);
            exportButton.addEventListener('click', handleExport);
            zoomInButton.addEventListener('click', zoomIn);
            zoomOutButton.addEventListener('click', zoomOut);
            
            mapContainer.addEventListener('mousedown', startPainting);
            document.addEventListener('mouseup', stopPainting);
            mapContainer.addEventListener('mouseleave', stopPainting);

            await loadBlockData();
            createTileStyles(); 

            initializeMap();
            initBlockSelector();
        };

    </script>
</body>
</html>
