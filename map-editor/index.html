<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scratcharia Map Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #map-container {
            display: grid;
            grid-template-columns: repeat(350, 2px); 
            grid-template-rows: repeat(160, 2px);
            width: 700px;
            height: 320px; 
            overflow: auto;
            border: 1px solid #475569;
            transform-origin: top left;
            transition: transform 0.2s ease-in-out;
        }
        .tile {
            width: 2px;
            height: 2px;
            box-sizing: border-box;
            cursor: crosshair;
            transition: background-color 0.1s;
        }
        #map-container::-webkit-scrollbar { width: 8px; height: 8px; }
        #map-container::-webkit-scrollbar-thumb { background: #3b82f6; border-radius: 4px; }
        #map-container::-webkit-scrollbar-track { background: #1e293b; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        };
    </script>
</head>
<body class="bg-gray-900 text-gray-100 p-4 font-sans min-h-screen flex flex-col items-center">

    <div class="max-w-5xl w-full">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">350x160 Tile Map Editor (Data Loaded)</h1>
        
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg mb-6 flex flex-wrap justify-between items-center space-y-4 md:space-y-0">
            
            <div class="flex flex-col space-y-2 w-full md:w-1/3">
                <h2 class="text-xl font-semibold text-blue-300">Block Selector</h2>
                <select id="blockSelectorDropdown" class="p-3 border border-gray-600 rounded-lg bg-gray-700 text-sm focus:ring-blue-500 focus:border-blue-500 text-white cursor-pointer"></select>
                <div id="current-block-preview" class="flex items-center mt-2 text-sm font-medium">
                    Current: <span id="current-block-icon" class="mx-2 text-xl inline-block w-6 h-6 text-center leading-6">◻️</span>
                    <span id="current-block-label">Loading...</span>
                </div>
            </div>
            
            <div class="flex items-center space-x-2 md:w-1/4 justify-center">
                <span class="text-lg font-medium">Zoom:</span>
                <button id="zoomOutButton" class="bg-gray-700 hover:bg-gray-600 text-white font-bold w-10 h-10 rounded-full text-xl shadow-md transition duration-200">-</button>
                <span id="zoomLevelDisplay" class="text-xl font-bold text-blue-300 w-12 text-center">1.0x</span>
                <button id="zoomInButton" class="bg-gray-700 hover:bg-gray-600 text-white font-bold w-10 h-10 rounded-full text-xl shadow-md transition duration-200">+</button>
            </div>
            
            <div class="flex flex-col space-y-2 w-full md:w-1/3">
                <input type="file" id="fileInput" accept=".txt,.csv" class="p-2 border border-gray-600 rounded-lg bg-gray-700 text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600">
                <button id="exportButton" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                    Export Map Data
                </button>
            </div>
        </div>
        
        <div class="flex flex-col items-center">
            <div id="status-message" class="text-red-400 mb-2 h-6"></div>
            <div id="map-wrapper" class="p-2 bg-gray-700 rounded-xl shadow-inner">
                <div id="map-container" class="transform origin-top-left">
                </div>
            </div>
            <p class="mt-4 text-sm text-gray-400">Map dimensions: 350 (W) x 160 (H) = 56,000 tiles.</p>
            <p class="text-xs text-gray-500 mt-1">Data maps from the bottom-right tile (349, 159) backwards to the top-left.</p>
        </div>

    </div>
    
    <script>
        const MAP_WIDTH = 350;
        const MAP_HEIGHT = 160;
        const TOTAL_TILES = MAP_WIDTH * MAP_HEIGHT;
        const ZOOM_STEP = 0.5;
        const MIN_ZOOM = 1.0;
        const MAX_ZOOM = 4.0;
        
        const EXTERNAL_BLOCK_DATA_URL = "https://raw.githack.com/terraxcata/scratcharia-javascript/refs/heads/main/map-editor/extracted_costumes.json";
        
        let mapData = new Array(TOTAL_TILES).fill(0); 
        let currentBlockType = 0;
        let currentZoomLevel = MIN_ZOOM;
        let BLOCK_TYPES = {};
        let MAX_BLOCK_TYPE = 0;
        let isPainting = false;

        const mapContainer = document.getElementById('map-container');
        const fileInput = document.getElementById('fileInput');
        const exportButton = document.getElementById('exportButton');
        const statusMessage = document.getElementById('status-message');
        const blockSelectorDropdown = document.getElementById('blockSelectorDropdown');
        const currentBlockLabel = document.getElementById('current-block-label');
        const currentBlockIcon = document.getElementById('current-block-icon');
        const zoomInButton = document.getElementById('zoomInButton');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');

        const EMPTY_BLOCK_FALLBACK = {
            id: 0,
            costume_name: "empty",
            label: "Empty",
            mime_type: "image/png",
            base64_image_data: "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAFVJREFUWEdjYBgFo2AUjIJRMApGATgDEzT/YNAA0kLgXg0D8n80wAg0D/L/0wCMAH6+BGAoGAWjYBSMGgAAMoYwB1iJk7IAAAAASUVORK5CYII="
        };

        async function loadBlockData() {
            try {
                statusMessage.textContent = `Fetching block definitions from ${EXTERNAL_BLOCK_DATA_URL}...`;
                
                const response = await fetch(EXTERNAL_BLOCK_DATA_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const dataArray = await response.json();
                
                BLOCK_TYPES = {};
                
                BLOCK_TYPES[0] = EMPTY_BLOCK_FALLBACK;
                
                dataArray.forEach((block, index) => {
                    const id = index + 1; 
                    BLOCK_TYPES[id] = { 
                        id: id,
                        label: block.costume_name, 
                        ...block 
                    };
                });
                
                MAX_BLOCK_TYPE = dataArray.length;
                
                statusMessage.textContent = `Successfully loaded ${Object.keys(BLOCK_TYPES).length} block definitions.`;
                setTimeout(() => statusMessage.textContent = '', 3000);
                
                return BLOCK_TYPES;

            } catch (error) {
                const errorMessage = `Error loading block data: ${error.message}. Using default minimum set.`;
                statusMessage.textContent = errorMessage;
                console.error(errorMessage, error);
                
                BLOCK_TYPES = {
                    0: EMPTY_BLOCK_FALLBACK,
                    1: { id: 1, label: 'Error Block', costume_name: 'error', mime_type: 'image/png', base64_image_data: "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAKklEQVR42u3BAQEAAAABIP6fOpgAEAAAAAAAAAAAAAAAAAAAAAF+jYABg2fN+hAAAAABJRU5ErkJggg==" }
                };
                MAX_BLOCK_TYPE = 1;
                return BLOCK_TYPES;
            }
        }

        function paintTile(tileElement) {
            if (!tileElement || !tileElement.classList.contains('tile')) return;

            const index = Number(tileElement.dataset.index);
            const newBlockValue = currentBlockType;
            
            const type = BLOCK_TYPES[newBlockValue] || BLOCK_TYPES[0];
            
            const base64Mime = type.mime_type || 'image/png';
            const base64Data = type.base64_image_data;

            if (base64Data) {
                tileElement.style.backgroundImage = `url(data:${base64Mime};base64,${base64Data})`;
                tileElement.style.backgroundSize = '2px 2px';
                tileElement.style.backgroundColor = 'transparent';
            } else {
                tileElement.style.backgroundImage = 'none';
                tileElement.style.backgroundColor = '#111827';
            }
            
            tileElement.dataset.value = newBlockValue;
            
            mapData[index] = newBlockValue;
        }

        function handleTileMouseOver(event) {
            if (isPainting && event.target.classList.contains('tile')) {
                paintTile(event.target);
            }
        }

        function startPainting(event) {
            if (event.buttons === 1 && event.target.classList.contains('tile')) { 
                isPainting = true;
                paintTile(event.target);
            }
        }

        function stopPainting() {
            isPainting = false;
        }

        function renderMap(data) {
            mapContainer.innerHTML = ''; 

            const grid = Array.from({ length: MAP_HEIGHT }, () => new Array(MAP_WIDTH).fill(0));
            let dataIndex = 0;
            for (let y = MAP_HEIGHT - 1; y >= 0; y--) {
                for (let x = MAP_WIDTH - 1; x >= 0; x--) {
                    const tileValue = (dataIndex < data.length) ? (data[dataIndex] || 0) : 0;
                    grid[y][x] = tileValue;
                    dataIndex++;
                }
            }

            const finalMapData = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    finalMapData.push(grid[y][x]);
                }
            }
            mapData = finalMapData;

            finalMapData.forEach((value, index) => {
                const blockId = value <= MAX_BLOCK_TYPE ? value : 0;
                const type = BLOCK_TYPES[blockId] || BLOCK_TYPES[0];

                const tile = document.createElement('div');
                tile.className = `tile`;
                
                const base64Mime = type.mime_type || 'image/png';
                const base64Data = type.base64_image_data;
                
                if (base64Data) {
                    tile.style.backgroundImage = `url(data:${base64Mime};base64,${base64Data})`;
                    tile.style.backgroundSize = '2px 2px';
                    tile.style.backgroundColor = 'transparent';
                } else {
                    tile.style.backgroundColor = '#111827'; 
                }
                
                tile.dataset.index = index;
                tile.dataset.value = blockId;
                
                tile.addEventListener('mouseover', handleTileMouseOver);
                
                mapContainer.appendChild(tile);
            });
        }

        function initBlockSelector() {
            blockSelectorDropdown.innerHTML = '';
            
            Object.keys(BLOCK_TYPES).map(Number).sort((a, b) => a - b).forEach(key => {
                const type = BLOCK_TYPES[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${key} - ${type.costume_name}`;
                
                blockSelectorDropdown.appendChild(option);
            });

            blockSelectorDropdown.addEventListener('change', (e) => {
                setCurrentBlockType(e.target.value);
            });

            setCurrentBlockType(0);
        }

        function setCurrentBlockType(type) {
            currentBlockType = Number(type);
            const block = BLOCK_TYPES[currentBlockType] || BLOCK_TYPES[0];
            
            currentBlockLabel.textContent = `${currentBlockType} - ${block.costume_name}`;
            
            const base64Mime = block.mime_type || 'image/png';
            const base64Data = block.base64_image_data;
            if (base64Data) {
                currentBlockIcon.innerHTML = '';
                currentBlockIcon.style.backgroundImage = `url(data:${base64Mime};base64,${base64Data})`;
                currentBlockIcon.style.backgroundSize = '100% 100%';
                currentBlockIcon.style.backgroundColor = 'transparent';
            } else {
                currentBlockIcon.innerHTML = '◻️';
                currentBlockIcon.style.backgroundImage = 'none';
                currentBlockIcon.style.backgroundColor = 'transparent';
            }
            
            blockSelectorDropdown.value = currentBlockType;
        }

        function updateZoom() {
            mapContainer.style.transform = `scale(${currentZoomLevel})`;
            zoomLevelDisplay.textContent = `${currentZoomLevel.toFixed(1)}x`;

            const scaledWidth = 700 * currentZoomLevel;
            const scaledHeight = 320 * currentZoomLevel;

            document.getElementById('map-wrapper').style.width = currentZoomLevel > MIN_ZOOM ? `${scaledWidth + 4}px` : '704px';
            document.getElementById('map-wrapper').style.height = currentZoomLevel > MIN_ZOOM ? `${scaledHeight + 4}px` : '324px';

            zoomOutButton.disabled = currentZoomLevel <= MIN_ZOOM;
            zoomInButton.disabled = currentZoomLevel >= MAX_ZOOM;
            zoomOutButton.classList.toggle('opacity-50', zoomOutButton.disabled);
            zoomInButton.classList.toggle('opacity-50', zoomInButton.disabled);
        }

        function zoomIn() {
            if (currentZoomLevel < MAX_ZOOM) {
                currentZoomLevel = Math.min(MAX_BLOCK_TYPE, currentZoomLevel + ZOOM_STEP);
                updateZoom();
            }
        }

        function zoomOut() {
            if (currentZoomLevel > MIN_ZOOM) {
                currentZoomLevel = Math.max(MIN_ZOOM, currentZoomLevel - ZOOM_STEP);
                updateZoom();
            }
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    const rawValues = content.split(/[,\s]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0)
                        .map(Number);
                    
                    const validData = rawValues.map(v => {
                        const clamped = Math.min(Math.max(0, v), MAX_BLOCK_TYPE);
                        return isNaN(v) ? 0 : clamped;
                    });

                    if (validData.length === 0) {
                        statusMessage.textContent = 'Error: Loaded file contains no valid numerical data.';
                        setTimeout(() => statusMessage.textContent = '', 3000);
                        return;
                    }

                    statusMessage.textContent = `Loaded ${validData.length} values. Mapping to 350x160 grid (BR to TL).`;
                    setTimeout(() => statusMessage.textContent = '', 4000);
                    
                    renderMap(validData);

                } catch (error) {
                    statusMessage.textContent = 'Error processing file data.';
                    console.error('File processing error:', error);
                }
            };
            reader.readAsText(file);
        }

        function handleExport() {
            const grid = [];
            for (let i = 0; i < TOTAL_TILES; i++) {
                const y = Math.floor(i / MAP_WIDTH);
                const x = i % MAP_WIDTH;
                grid.push({ x, y, value: mapData[i] });
            }

            grid.sort((a, b) => {
                if (a.y !== b.y) { return b.y - a.y; }
                return b.x - a.x;
            });

            const outputData = grid.map(item => item.value);
            const csvContent = outputData.join(',');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'map_data.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            statusMessage.textContent = 'Map data exported successfully!';
            setTimeout(() => statusMessage.textContent = '', 3000);
        }
        
        window.onload = async () => {
            await loadBlockData();

            fileInput.addEventListener('change', handleFileLoad);
            exportButton.addEventListener('click', handleExport);
            zoomInButton.addEventListener('click', zoomIn);
            zoomOutButton.addEventListener('click', zoomOut);
            
            mapContainer.addEventListener('mousedown', startPainting);
            document.addEventListener('mouseup', stopPainting);
            mapContainer.addEventListener('mouseleave', stopPainting);

            initBlockSelector();
            renderMap(mapData);
            updateZoom(); 
        };

    </script>
</body>
</html>
