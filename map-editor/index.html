<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scratcharia Map Editor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        .card {
            background-color: #1e1e1e !important;
            padding: 20px;
            border-radius: 12px;
            width: 100%;
            max-width: 1000px;
        }
        #map-container {
            display: grid;
            overflow: auto;
            border: 1px solid #444;
            transform-origin: top left;
            transition: transform 0.2s ease-in-out;
            background-color: #000;
        }
        .tile {
            width: 2px;
            height: 2px;
            box-sizing: border-box;
            cursor: crosshair;
        }
        #map-wrapper {
            background-color: #263238;
            padding: 8px;
            border-radius: 8px;
            overflow: auto;
            max-width: 100%;
            max-height: 600px;
        }
        select, input {
            color: white !important;
            border-bottom: 1px solid #555 !important;
        }
        .input-field label {
            color: #9e9e9e !important;
        }
        .btn {
            text-transform: none;
            border-radius: 8px;
        }
        #status-message {
            min-height: 24px;
        }
        #current-block-icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            vertical-align: middle;
            margin: 0 8px;
        }
        .browser-default {
            background-color: #333;
            color: white;
            border: 1px solid #444;
            padding: 5px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div class="card z-depth-4">
        <h4 class="blue-text text-lighten-2">Scratcharia Map Editor</h4>
        
        <div class="row">
            <div class="col s12 m4">
                <h6 class="blue-text text-lighten-4">Block Selector</h6>
                <select id="blockSelectorDropdown" class="browser-default"></select>
                <div id="current-block-preview" class="section">
                    <span>Current:</span>
                    <span id="current-block-icon">◻️</span>
                    <span id="current-block-label">Loading...</span>
                </div>
            </div>

            <div class="col s12 m4">
                <h6 class="blue-text text-lighten-4">Map Size (Tiles)</h6>
                <div class="row" style="margin-bottom: 0;">
                    <div class="input-field col s6">
                        <input type="number" id="mapWidthInput" value="350">
                        <label class="active">Width</label>
                    </div>
                    <div class="input-field col s6">
                        <input type="number" id="mapHeightInput" value="160">
                        <label class="active">Height</label>
                    </div>
                </div>
                <button id="updateSizeButton" class="btn blue darken-2 waves-effect waves-light full-width" style="width:100%">Update Size</button>
                
                <div class="center-align" style="margin-top: 15px;">
                    <button id="zoomOutButton" class="btn-floating btn-small grey darken-3 waves-effect"><i class="material-icons">remove</i></button>
                    <span id="zoomLevelDisplay" style="margin: 0 15px; font-weight: bold;">1.0x</span>
                    <button id="zoomInButton" class="btn-floating btn-small grey darken-3 waves-effect"><i class="material-icons">add</i></button>
                </div>
            </div>

            <div class="col s12 m4">
                <h6 class="blue-text text-lighten-4">Data Source</h6>
                <input type="text" id="customBlockUrlInput" value="https://raw.githack.com/terraxcata/scratcharia-javascript/refs/heads/main/map-editor/extracted_costumes.json">
                <button id="loadCustomBlocksButton" class="btn indigo darken-2 waves-effect waves-light" style="width:100%; margin-bottom: 10px;">Load Blocks</button>
                
                <div class="file-field input-field">
                    <div class="btn blue-grey">
                        <span>Import</span>
                        <input type="file" id="fileInput" accept=".txt,.csv">
                    </div>
                    <div class="file-path-wrapper">
                        <input class="file-path validate" type="text" placeholder="Upload map">
                    </div>
                </div>
                <button id="exportButton" class="btn green darken-2 waves-effect waves-light" style="width:100%">Export Map Data</button>
            </div>
        </div>

        <div class="center-align">
            <div id="status-message" class="red-text text-lighten-2"></div>
            <div id="map-wrapper">
                <div id="map-container"></div>
            </div>
            <p id="dimensionsDisplay" class="grey-text text-lighten-1" style="font-size: 0.8rem; margin-top:10px;"></p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script>
        let MAP_WIDTH = 350;
        let MAP_HEIGHT = 160;
        let TOTAL_TILES = 0;
        const ZOOM_STEP = 0.5;
        const MIN_ZOOM = 1.0;
        const MAX_ZOOM = 4.0;
        
        let mapData = []; 
        let currentBlockType = 0;
        let currentZoomLevel = MIN_ZOOM;
        let BLOCK_TYPES = {};
        let MAX_BLOCK_TYPE = 0;
        let isPainting = false;

        const mapContainer = document.getElementById('map-container');
        const fileInput = document.getElementById('fileInput');
        const exportButton = document.getElementById('exportButton');
        const statusMessage = document.getElementById('status-message');
        const blockSelectorDropdown = document.getElementById('blockSelectorDropdown');
        const currentBlockLabel = document.getElementById('current-block-label');
        const currentBlockIcon = document.getElementById('current-block-icon');
        const zoomInButton = document.getElementById('zoomInButton');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');
        const mapWidthInput = document.getElementById('mapWidthInput');
        const mapHeightInput = document.getElementById('mapHeightInput');
        const dimensionsDisplay = document.getElementById('dimensionsDisplay');
        const updateSizeButton = document.getElementById('updateSizeButton');
        const customBlockUrlInput = document.getElementById('customBlockUrlInput');
        const loadCustomBlocksButton = document.getElementById('loadCustomBlocksButton');

        const EMPTY_BLOCK_FALLBACK = {
            id: 0,
            costume_name: "air", 
            label: "Air",
            mime_type: null,
            base64_image_data: null 
        };

        function createTileStyles() {
            const styleSheet = document.getElementById('tile-styles') || document.createElement('style');
            styleSheet.id = 'tile-styles';
            let css = '';

            Object.keys(BLOCK_TYPES).map(Number).sort((a, b) => a - b).forEach(key => {
                const block = BLOCK_TYPES[key];
                const className = `block-${key}`;
                
                let blockCss = '';
                
                if (key === 0) {
                    blockCss = 'background-image: none !important; background-color: transparent !important;';
                } else if (block.base64_image_data) {
                    const base64Mime = block.mime_type || 'image/png';
                    blockCss = `
                        background-image: url(data:${base64Mime};base64,${block.base64_image_data});
                        background-size: 2px 2px;
                        background-color: transparent !important;
                    `;
                } else {
                    blockCss = 'background-image: none; background-color: #f87171 !important;';
                }

                css += `.tile.${className} { ${blockCss} }`;
            });

            styleSheet.textContent = css;
            if (!document.getElementById('tile-styles')) {
                document.head.appendChild(styleSheet);
            }
        }

        async function fetchAndProcessBlockData(url, sourceName) {
            try {
                statusMessage.textContent = `Fetching block definitions from ${sourceName}...`;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const dataArray = await response.json();
                
                const isInitialLoad = sourceName === 'default source'; 
                
                if (isInitialLoad) {
                    BLOCK_TYPES = {};
                    BLOCK_TYPES[0] = EMPTY_BLOCK_FALLBACK;
                }
                
                let currentId = isInitialLoad ? 1 : MAX_BLOCK_TYPE + 1; 
                
                dataArray.forEach((block) => {
                    BLOCK_TYPES[currentId] = { 
                        id: currentId,
                        label: block.costume_name, 
                        ...block 
                    };
                    currentId++;
                });
                
                MAX_BLOCK_TYPE = currentId - 1; 
                
                createTileStyles();
                initBlockSelector();
                
                statusMessage.textContent = `Successfully loaded and added ${dataArray.length} block definitions from ${sourceName}. Total blocks: ${MAX_BLOCK_TYPE}.`;
                setTimeout(() => statusMessage.textContent = '', 3000);
                
                return BLOCK_TYPES;

            } catch (error) {
                const errorMessage = `Error loading block data from ${sourceName}: ${error.message}.`;
                statusMessage.textContent = errorMessage;
                console.error(errorMessage, error);
                
                if (Object.keys(BLOCK_TYPES).length <= 1) {
                    BLOCK_TYPES = {
                        0: EMPTY_BLOCK_FALLBACK,
                        1: { id: 1, label: 'Error Block', costume_name: 'error', mime_type: 'image/png', base64_image_data: "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAKklEQVR42u3BAQEAAAABIP6fOpgAEAAAAAAAAAAAAAAAAAAAAAF+jYABg2fN+hAAAAABJRU5ErkJggg==" }
                    };
                    MAX_BLOCK_TYPE = 1;
                    createTileStyles();
                    initBlockSelector();
                }
                return BLOCK_TYPES;
            }
        }

        function loadCustomBlocks() {
            const url = customBlockUrlInput.value.trim();
            if (!url) {
                statusMessage.textContent = 'Please enter a valid URL.';
                setTimeout(() => statusMessage.textContent = '', 3000);
                return;
            }
            fetchAndProcessBlockData(url, 'custom URL'); 
        }

        function paintTile(tileElement) {
            if (!tileElement || !tileElement.classList.contains('tile')) return;

            const index = Number(tileElement.dataset.index);
            const oldBlockValue = Number(tileElement.dataset.value);
            const newBlockValue = currentBlockType;
            
            if (oldBlockValue === newBlockValue) return; 

            if (oldBlockValue !== undefined) {
                tileElement.classList.remove(`block-${oldBlockValue}`);
            }
            
            tileElement.classList.add(`block-${newBlockValue}`);
            
            tileElement.dataset.value = newBlockValue;
            mapData[index] = newBlockValue;
        }

        function handleTileMouseOver(event) {
            if (isPainting && event.target.classList.contains('tile')) {
                paintTile(event.target);
            }
        }

        function startPainting(event) {
            if (event.buttons === 1 && event.target.classList.contains('tile')) { 
                isPainting = true;
                paintTile(event.target);
            }
        }

        function stopPainting() {
            isPainting = false;
        }

        function renderMap(data) {
            mapContainer.innerHTML = ''; 
            const fragment = document.createDocumentFragment(); 

            const grid = Array.from({ length: MAP_HEIGHT }, () => new Array(MAP_WIDTH).fill(0));
            let dataIndex = 0;
            
            if (data.length === TOTAL_TILES) {
                for (let y = MAP_HEIGHT - 1; y >= 0; y--) {
                    for (let x = MAP_WIDTH - 1; x >= 0; x--) {
                        const tileValue = (dataIndex < data.length) ? (data[dataIndex] || 0) : 0;
                        grid[y][x] = tileValue;
                        dataIndex++;
                    }
                }
            } else {
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        grid[y][x] = 0;
                    }
                }
            }

            const finalMapData = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    finalMapData.push(grid[y][x]);
                }
            }
            mapData = finalMapData;

            finalMapData.forEach((value, index) => {
                const blockId = value <= MAX_BLOCK_TYPE ? value : 0;
                
                const tile = document.createElement('div');
                tile.className = `tile block-${blockId}`; 
                
                tile.dataset.index = index;
                tile.dataset.value = blockId;
                
                tile.addEventListener('mouseover', handleTileMouseOver);
                
                fragment.appendChild(tile); 
            });

            mapContainer.appendChild(fragment); 
        }

        function initBlockSelector() {
            blockSelectorDropdown.innerHTML = '';
            
            Object.keys(BLOCK_TYPES).map(Number).sort((a, b) => a - b).forEach(key => {
                const type = BLOCK_TYPES[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${key} - ${type.costume_name}`;
                
                blockSelectorDropdown.appendChild(option);
            });

            blockSelectorDropdown.addEventListener('change', (e) => {
                setCurrentBlockType(e.target.value);
            });

            setCurrentBlockType(0);
        }

        function setCurrentBlockType(type) {
            currentBlockType = Number(type);
            const block = BLOCK_TYPES[currentBlockType] || BLOCK_TYPES[0];
            
            currentBlockLabel.textContent = `${currentBlockType} - ${block.costume_name}`;
            
            const base64Mime = block.mime_type || 'image/png';
            const base64Data = block.base64_image_data;
            if (base64Data) {
                currentBlockIcon.innerHTML = '';
                currentBlockIcon.style.backgroundImage = `url(data:${base64Mime};base64,${base64Data})`;
                currentBlockIcon.style.backgroundSize = '100% 100%';
                currentBlockIcon.style.backgroundColor = 'transparent';
            } else {
                currentBlockIcon.innerHTML = '◻️';
                currentBlockIcon.style.backgroundImage = 'none';
                currentBlockIcon.style.backgroundColor = 'transparent';
            }
            
            blockSelectorDropdown.value = currentBlockType;
        }

        function updateZoom() {
            mapContainer.style.transform = `scale(${currentZoomLevel})`;
            zoomLevelDisplay.textContent = `${currentZoomLevel.toFixed(1)}x`;

            const baseWidthPx = MAP_WIDTH * 2;
            const baseHeightPx = MAP_HEIGHT * 2;

            const scaledWidth = baseWidthPx * currentZoomLevel;
            const scaledHeight = baseHeightPx * currentZoomLevel;
            
            document.getElementById('map-wrapper').style.width = currentZoomLevel > MIN_ZOOM ? `${scaledWidth + 4}px` : `${baseWidthPx + 4}px`;
            document.getElementById('map-wrapper').style.height = currentZoomLevel > MIN_ZOOM ? `${scaledHeight + 4}px` : `${baseHeightPx + 4}px`;

            zoomOutButton.disabled = currentZoomLevel <= MIN_ZOOM;
            zoomInButton.disabled = currentZoomLevel >= MAX_ZOOM;
            zoomOutButton.style.opacity = zoomOutButton.disabled ? "0.5" : "1";
            zoomInButton.style.opacity = zoomInButton.disabled ? "0.5" : "1";
        }

        function zoomIn() {
            if (currentZoomLevel < MAX_ZOOM) {
                currentZoomLevel = Math.min(MAX_ZOOM, currentZoomLevel + ZOOM_STEP); 
                updateZoom();
            }
        }

        function zoomOut() {
            if (currentZoomLevel > MIN_ZOOM) {
                currentZoomLevel = Math.max(MIN_ZOOM, currentZoomLevel - ZOOM_STEP);
                updateZoom();
            }
        }

        function initializeMap() {
            MAP_WIDTH = parseInt(mapWidthInput.value) || 350;
            MAP_HEIGHT = parseInt(mapHeightInput.value) || 160;

            MAP_WIDTH = Math.max(1, Math.min(1000, MAP_WIDTH));
            MAP_HEIGHT = Math.max(1, Math.min(1000, MAP_HEIGHT));
            
            mapWidthInput.value = MAP_WIDTH;
            mapHeightInput.value = MAP_HEIGHT;

            TOTAL_TILES = MAP_WIDTH * MAP_HEIGHT;

            mapContainer.style.gridTemplateColumns = `repeat(${MAP_WIDTH}, 2px)`;
            mapContainer.style.gridTemplateRows = `repeat(${MAP_HEIGHT}, 2px)`;
            mapContainer.style.width = `${MAP_WIDTH * 2}px`;
            mapContainer.style.height = `${MAP_HEIGHT * 2}px`;

            mapData = new Array(TOTAL_TILES).fill(0);
            
            dimensionsDisplay.textContent = `Map dimensions: ${MAP_WIDTH} (W) x ${MAP_HEIGHT} (H) = ${TOTAL_TILES.toLocaleString()} tiles.`;
            
            renderMap(mapData);
            updateZoom();
        }

        function updateDimensions() {
            const oldWidth = MAP_WIDTH;
            const oldHeight = MAP_HEIGHT;
            
            const newWidth = Math.max(1, Math.min(1000, parseInt(mapWidthInput.value) || 350));
            const newHeight = Math.max(1, Math.min(1000, parseInt(mapHeightInput.value) || 160));
            
            if (newWidth === oldWidth && newHeight === oldHeight) return;

            const oldMapData = [...mapData];
            
            MAP_WIDTH = newWidth;
            MAP_HEIGHT = newHeight;
            TOTAL_TILES = MAP_WIDTH * MAP_HEIGHT;

            mapWidthInput.value = MAP_WIDTH;
            mapHeightInput.value = MAP_HEIGHT;

            const newMapData = new Array(TOTAL_TILES).fill(0);

            const widthLimit = Math.min(oldWidth, newWidth);
            const heightLimit = Math.min(oldHeight, newHeight);

            for (let y = 0; y < heightLimit; y++) {
                for (let x = 0; x < widthLimit; x++) {
                    const oldIndex = y * oldWidth + x;
                    const newIndex = y * newWidth + x;
                    
                    if (oldIndex < oldMapData.length && newIndex < newMapData.length) {
                         newMapData[newIndex] = oldMapData[oldIndex];
                    }
                }
            }
            
            mapContainer.style.gridTemplateColumns = `repeat(${MAP_WIDTH}, 2px)`;
            mapContainer.style.gridTemplateRows = `repeat(${MAP_HEIGHT}, 2px)`;
            mapContainer.style.width = `${MAP_WIDTH * 2}px`;
            mapContainer.style.height = `${MAP_HEIGHT * 2}px`;

            dimensionsDisplay.textContent = `Map dimensions: ${MAP_WIDTH} (W) x ${MAP_HEIGHT} (H) = ${TOTAL_TILES.toLocaleString()} tiles.`;
            
            renderMap(newMapData);
            updateZoom();

            statusMessage.textContent = 'Map Updated.';
            setTimeout(() => statusMessage.textContent = '', 4000);
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = e.target.result;
                    const rawValues = content.split(/[,\s]+/)
                        .map(s => s.trim())
                        .filter(s => s.length > 0)
                        .map(Number);
                    
                    if (rawValues.length !== TOTAL_TILES) {
                        statusMessage.textContent = `Warning: Loaded ${rawValues.length} values, expected ${TOTAL_TILES}.`;
                    }
                    
                    const validData = rawValues.map(v => {
                        const clamped = Math.min(Math.max(0, v), MAX_BLOCK_TYPE);
                        return isNaN(v) ? 0 : clamped;
                    });

                    if (validData.length === 0) {
                        statusMessage.textContent = 'Error: No valid numerical data.';
                        setTimeout(() => statusMessage.textContent = '', 3000);
                        return;
                    }

                    renderMap(validData);
                    statusMessage.textContent = `Map data loaded successfully!`;
                    setTimeout(() => statusMessage.textContent = '', 4000);
                    

                } catch (error) {
                    statusMessage.textContent = 'Error processing file data.';
                    console.error('File processing error:', error);
                }
            };
            reader.readAsText(file);
        }

        function handleExport() {
            const grid = [];
            for (let i = 0; i < TOTAL_TILES; i++) {
                const y = Math.floor(i / MAP_WIDTH);
                const x = i % MAP_WIDTH;
                grid.push({ x, y, value: mapData[i] });
            }

            grid.sort((a, b) => {
                if (a.y !== b.y) { return b.y - a.y; }
                return b.x - a.x;
            });

            const outputData = grid.map(item => item.value);
            const textContent = outputData.join('\n');
            
            const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `map_data_${MAP_WIDTH}x${MAP_HEIGHT}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            statusMessage.textContent = 'Map data exported successfully!';
            setTimeout(() => statusMessage.textContent = '', 3000);
        }
        
        window.onload = async () => {
            loadCustomBlocksButton.addEventListener('click', loadCustomBlocks);
            updateSizeButton.addEventListener('click', updateDimensions);

            fileInput.addEventListener('change', handleFileLoad);
            exportButton.addEventListener('click', handleExport);
            zoomInButton.addEventListener('click', zoomIn);
            zoomOutButton.addEventListener('click', zoomOut);
            
            mapContainer.addEventListener('mousedown', startPainting);
            document.addEventListener('mouseup', stopPainting);
            mapContainer.addEventListener('mouseleave', stopPainting);

            await fetchAndProcessBlockData(customBlockUrlInput.value, 'default source');

            initializeMap();
        };

    </script>
</body>
</html>
